Александр Борисович Вавренюк

Курс – структурное программирование (структурное значит без ООП), чистый Си. Язык Си – инструмент, основа - алгоритмы

60 баллов – лабораторный практикум, 40 баллов – электронный тест (20 вопросов, в каждом 4 варианта ответа). Лабораторных работ 7 штук, первые две по 5 баллов, остальные 5 работ по 10 баллов. На каждую лабораторную работу дается 2 занятия

Лабы:
1)    Работа с натуральными числами
2)    Работа с числовыми рядами
3)    Массивы
4)    Строки с использованием библиотеки string.h
5)    Строки без использования библиотеки string.h
6)    Файлы
7)    Списки

Основной принцип структурного программирования сформулировал Никлаус Вирт:
Алгоритмы + Структуры данных = Программа

Главная парадигма структурного программирования - первичным является алгоритм в отличии от ООП, где первичны данные

Язык C изначально создан для перезаписи ядра ОС Unix с Ассемблера

Литература:
The C programming language (Kernighan B., Ritchie D.)
Курс программирования на языке Си (Подбельский, Фомин)
Практикум по программированию на языке Си (Подбельский)

Процессор понимает только машинный язык. Программа, которая преобразует программу с “человеческого” языка называется транслятор. Транслятор бывает двух типов: компилятор и интерпретатор. У нас будет использоваться компилятор: полностью переводит код с алгоритмического языка в код программы (машинный язык)

Прототипы функций содержатся в заголовочных файлах

Первая стадия обработки программы (еще до компилятора) – препроцессор (обрабатывает разные директивы, начинаются с символа #, например @include)
Каждый файл .c компилятор превращает в файл .o
Последняя стадия (называется редактор связей или компоновщик или линковщик), которая все файлы объединяет в один. Это загрузчоный модуль, который уже можно запускать

test.c (исходный файд)
test (без расширения - исполнимый файл)

#cc test.c -o test

vim

$ vi (можно открыть существующий файл, можно указать несуществующий)

Три режима vi:
1) командная строка
2) командный
3) редактирование

При входе в редактор попадете в командный режим (нажатие любой клавиши воспринимается как некоторая команда, из него можно попасть в другие режимы)

В режиме редактирования нажатие любой клавиши - появление этой клавиши на экране

Существует как минимум 6 команд, для попадания из командного режима в режим редактирования: i, I, a, A, o, O. Если пустой буфер, то они ничем не отличаются. Иначе - куда будет начинаться ввод текста:
i - ввод текста перед символом, на котором находится курсор
I - не важно где стоит курсор, главное на какой строке стоит: текст начнет вводится в начало строки, где стоит курсор
a - после символа, где стоит курсор
A - в конец строки, на которой стоит курсор
o - добавится новая пустая строка под текущей и туда начнется воод текста
O - добавится новая пустая строка над текущей и туда начнется ввод текста\

После ввода текста с помощью ESC можно вернуться в командный режим

командный режим (при условии, что дали имя, например: $vi test.c, а не $vi)
Выйти с сохранением: shift + zz
Выйти без сохранения: shift + zq
Удалить строку, на которой стоит курсор (помещается в буфер): dd
Если строка в буфере, то если нажать p, то строка вставится после строки, где курсор или если нажать P - то вставится до строки, где стоит курсор

Можно поместить строку в буфер не удаляя (например, чтобы размножить): yy
Также в командном режиме можно удалить один символ:
x - на котором стоит курсор
X - слева от курсора

Коэффициент повторения
Любую команду можно выполнить много раз (сколько хотите). Для этого нужно набрать перед командой коэффициент повторения (не обязательно одну цифру, можно несколько):
35dd - начиная с текущей строки удалиться 35 строк (если запутались, то нажать ESC, для отмены коэффициента)

Навигация по строкам:
G + номер строки - попасть на строку с номером: 
G - попасть на последнюю строку
dd + shift+ G - удалить всё с текущей строки

Режим командной строки (shift + :)
Курсор оказывается внизу, можно набрать команду. После нажатия enter команда выполнится и опять окажемся в командном режиме. Для новых команд надо повторить вызов режима командной строки

:set nu - получить нумерацию строк
:12 + enter (12 строка, например) - попасть на строку с номером
:w + enter - сохраниться, но не выйти (с текущим именем)
:w test.c + enter - сохраниться с другим именем
:w! test.c + enter - перезаписать существующий файл
:wq - выйти с сохранением
:q - выйти без сохранения
:q! - принудительно выйти без сохранения

**Данные** делятся на две группы:
- переменные
- константы

Обе эти группы в свою очередь также делятся на 3 типа:
- числа
- коды
- адреса

1) числа (целые и вещественные)
   - целые числа (int) - базовый тип данных (-2^31 ÷ 2^31-1, 32 бита или 4 байта). 32 разряда, самый старший используется под знак

	`unsigned int` (можно int не указывать потому что базовый тип) - если нужно использовать диапазон шире (без знака, 0 ÷ 2^32-1, 32 бита или 4 байта)
	
	`short int` (можно int не указывать): -2^15 ÷ 2^15 -1 (2 байта)
	
	`unsigned short`: 0 ÷ 2^16 -1
	
	`long int`: -2^63 ÷ 2^63-1 (64 бита или 8 байт)

	`unsigned long`: 0 ÷ 2^64 -1
	
	Константа по умолчанию int (если она помещается в int), в противном случае long. Если необходимо, чтобы маленькое число, но под нее было выделено 8 байт и была типа long, то необходимо добавить модифактор после конастанты, например: 16l. Аналогично 16s для short, 16u для unsigned

   - вещественные числа (числа, предназначенные для хранения какой-либо физической величины):
	`float` (одинарная точность, 4 байта)
	`double`	(двойная точность, 8 байт)
	
	По умолчанию любая константа (если она не целая, то есть имеет точку или e) имеет тип double, например: 12. или 13.5. Экпоненциальная форма (число в виде мантиссы и порядка, то есть пишется мантисса + e + порядок, 
	например: 13.5e-5 = 13.5x1*0^-5)
	
	С помощью модификатора `f` можно определить константу как `float` (чтобы занимала меньше места, но будет менее точной)
	
	float - точность 5 или 6 десятичных знаков
	double - точность 15 или 16 десятичных знаков
	
	Си понимает константы не только десятичные, но восьмеричные, а также шестнадцатеричные. Если ничего не указано, то константа по умолчанию десятичная, например: 12. Если начинается с нуля, то восьмеричная, например: 012. Если начинается с 0x или 0X, например: 0x12, то шестнадцатеричная (буквы от a до f)
	
2) коды (предназначены для ввода-вывода)
   Символы представляются в программе при помощи кодов. У каждого символа есть ASC код (набор чисел 0÷255, по сути беззнаковый байт: 0÷2^8-1)
   
   Символьные константы представляются при помощи `'` (апостроф) вокруг, например `'a'`. 
   
   Этот тип называется `char`, по умолчанию он знаковый (-128÷127 или -2^7÷2^7-1)
   
   "особые" символы обозначаются слешем(`\`): `\n, \r, \t, \o` и т.д. А чтобы указать обратный слеш, его нужно указать два раза(`\\`)
   
   константа '\\0' - занимает 1 байт
   константа 0 - занимает 4 байта
   
3) адреса - специальный тип данных (позволяют использовать динамическую память), то есть можно объявлять переменные, которые хранят в себе адрес, где хранится другая переменная. Адрес на что-то указывает. У каждого байта есть адрес  Целое число занимает 4 байта, вещественное - 8 байт. Какой адрес указать? Всегда указывается адрес самого младшего байта и несколько байтов следующих подряд
  
   Как определяется указатель:
   `int*`
   `char*`
   `double*`
   `void*`(указатель, который ни на что не указывает), где `*` - то, на что он указывает
   
   Есть адреса, которые никуда не указывают: `NULL`
   `"abc"` - тоже адрес, занимает 4 байта (в памяти компилятор выделяет 4 ячейки (любая строка заканчивается нулевым байтом))
   
   'a' - код буквы a
   "а" - адрес (2 байта)
### Выражения
Состоит из операндов и операций, например: `a+b+c`
Операндом может быть переменная, константа, выражение (на самом деле любая переменная или константа - тоже простое выражение).

Ассоциативность бывает слева направо (при присваивании справа налево)

Всего приоритетов 15:
- Первый приоритет: круглые скобки, квадратные скобки, точка(`.`), стрелочка(`->`)
- Второй приоритет. У операций есть свойство: арность (количество операндов). Операции могут быть унарными, бинарными и тернарными (у сложения нет трех операндов! Пример: a+b+c. Только два!)

- Унарные операции (ассоциативность справа налево, т.е. для `-*a` сначала разыменование, а потом у полученного числа меняется знак)
  - `+a`
  - `-a`
  - `&`(получение адреса операнда (переменной))
  - `*`(обратное от последнего - разыменование (получить доступ к переменной по адресу?))
  - `!`(логическое **не**). Если применить к 0, то будет 1.
  - \` ~ (тильда). Побитовое отрицание или побитовая инверсия. В двоичной записи числа все 0 превращает в 1, а 0 превращает в 1.
  - `++` (инкремент) - увеличить на 1
  - `--` (декремент) - уменьшить на 1
  - (вписать тип) - преобразование типа (тоже операция)
  - `sizeof` - возвращает размер операнда в байтах
- третий приоритет (мультипликативные бинарные операции; если оба операнда целые, то операция целочисленная, иначе - вещественная. Распространенная ошибка: double f; f=5/3 (запишется единица, потому что оба операнда целочисленные)):
  - `*` - умножение
  - `/` - деление
  - `%` - взятие остатка
- четвертый приоритет (аддитивные бинарные операции)
  Это сложение и вычитание